# [0561. 数组拆分](https://leetcode.cn/problems/array-partition/)

- 标签：数组
- 难度：简单

## 题目大意

**描述**：给定一个长度为 `2 * n` 的整数数组 `nums`。

**要求**：将数组中的数拆分成 `n` 对，每对数求最小值，求 `n` 对数最小值的最大总和是多少。

**说明**：

- $1 \le n \le 10^4$。
- $nums.length == 2 * n$。
- $-10^4 \le nums[i] \le 10^4$。

**示例**：

- 示例 1：

```Python
输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
所以最大总和为 4
```
- 示例 2：

```Python
输入：nums = [6,2,6,5,1,2]
输出：9
解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9
```

## 解题思路

### 思路 1：排序

要想每对数最小值的总和最大，就得使每对数的最小值尽可能大。只有让较大的数与较大的数一起组合，较小的数与较小的数一起结合，才能才能使总和最大。

1. 对 `nums` 进行排序。
2. 将相邻两个元素的最小值进行相加，即得到结果。

### 思路 1：代码

```Python
class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()
        return sum(nums[::2])
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log_2n)$。
- **空间复杂度**：$O(1)$。

